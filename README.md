# Introduction 
The main source code for the first-year university PROM module. This project is the 'lock' system (the 'pick' system can be found [here](https://github.com/Gorea235/Uni-PROM-Pick)), where we have to use a Raspberry Pi and external hardware to create a system which can receive keypad inputs, check them against a code, and then output a signal to LEDs and buzzers informing the user on if their guess was correct.

This repo was initially hosted on VSTS to allow us to work on the code in private, which is why the names attached to the commits are odd.

# Functionality
The base system is a combination lock, with a keypad that connects a row and column when a button is pressed, and when this happens a buzzer is actived to inform the user that the key was acknowledged and the digit appears on screen for 1 second before being covered up with a `*`. There are 2 security modes, instant rejection and fully length rejection, which are toggled via the `IMMEDIATE_REJECT` variable in [`code_lock.py`](/src/code_lock.py). Immediate reject is where, as soon as an incorrect code is given, the system tells the user that it's incorrect, and displays the red LED. The reason for this mode is because it is the base mode that we needed according to the requirements of the project. The full length rejection is a standard password-like system, where it will only tell you if it's correct or not when you have entered all the digits. Adding this was an extention requirement, but I added it since it's a simple system to implement.

When digits are entered, they are shown on the screen for 1 second before being covered up. This is done by assuming the running terminal is a stanard bash linux one, and using the `\r` char to reset the cursor, and then re-writing the code with `*`s to cover it up. After 3 seconds from digit input, the full code input is cancelled and reset to blank. These 3 seconds are shown via a set of LEDs on the hardware of the Pi we were given (the code for this LED output was written by another teammate).

Since all of the input, and most of the output, is done through hardware, I wrote some GPIO handling libs that abstract a lot of the interfacing. These libs automatically handles wait times, contact bounce cleaning, and conversion between GPIO readings and digits. The keypad is a row-column switch system, where, when you press a button, it links a row and column together. To measure this, all of the rows are set to high, and the row we are currently reading is set to low. We then measure which column is low (since it uses a pull-up resistor on the columns), and the combination of which row we set and which column was low gives the digit that was pressed.

Outputting rows is done through a 3-bit data line, that feeds into an 8-bit IO expander, that outputs a single low line in a set of 8 depending on the input. This output system also drives the buzzer and LEDs, which use monostable multivibrators to convert the few-millisecond signal to a 1 or 3 second one. The data lines are put through a flip-flop chip so that the value can be preserved while reading, since input and output are done through the same data-lines. Because of this, the input data is put through a 3-state logic chip before reaching the main data lines, since this allows us to disable the input data being written to the data lines while we are attempting to write out.

# Building and Testing
In order to ensure correctness and iterate quickly, I wrote a build script that runs the unit testing, and then copies the items in the lib and src folders to a build folder if all the tests ran correctly. After that, we could use another script I wrote to push the build folder to the Pi, ready for us to run it. By doing this, we could make a change, and then check it against the tests and push it ready for full system testing, with the execution of 1 or 2 scripts.

# Final Notes
While having a fully working project like this was rewarding, it doesn't make up for the frustration of having to battle with hardware not working because it felt like it. I much prefered the software writing to the hardware building, mostly due to the fact that it was 99% working relatively easily, while the hardware screwed us over until the final days before presentation.
